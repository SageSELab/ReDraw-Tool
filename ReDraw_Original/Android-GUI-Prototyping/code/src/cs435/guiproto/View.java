package cs435.guiproto;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

/**
 * Base class for the GUI elements of an Android Activity.
 * 
 * Instead of using this class, employ Component (for Views with no children)
 * and ViewGroup (for Views with children), or one of the more appropriate subclasses.
 * Constructing Views (or their subclasses) directly is discouraged; use ViewBuilder
 * unless you have a good reason not to.
 * 
 * Our Views are not quite equivalent to Android Views; they retain
 * variables for their original position and size in the UIAutomatorViewer
 * file they came from.
 * 
 * They also have methods for generating XML layouts, resources, styles, etc.
 * from themselves and their children.
 * 
 * @author bdpowell, Curcio
 * 
 * please note: I have changed this class so that we have an element field,
 * this way parents can grab the elements of their children and add attributes.
 */
public abstract class View implements Comparable<View>{
	
	// Position in dp
	protected int x,y,height,width; 
	// Padding
	protected int pTop,pBottom, pLeft, pRight;
	// Included text; not used by all views
	protected String text;
	
	// Activity that this View is in
	protected ActivityHolder activity;
	// StyleFragment generated from getStyleFragment
	protected StyleFragment fragment;
	
	// Name of a component's Android class, like "LinearLayout"
	private String name;
	//only useful if it resides in a linear layout
	private float weight;
	// XML element generated by getLayoutElement(); can be used to
	// add attributes to the elements of this View's children, should it
	// have any
	private Element elem;
	
	// Unique ID
	private static int nextId = 0;
	protected int id;
	
	// Something like @+id/button1
	private String androidId = "";
	
	public HashMap<Constants.margin, Integer> marginMap;
	
	/**
	 * Create a new View
	 * 
	 * DO NOT use this directly! Use ViewBuilder instead.
	 * @param name View node's name, e.g. "Button"
	 */
	public View(String name) {
		this.name = name;
		id = nextId;
		androidId = "@+id/" + name + id;
		
		nextId++;
	}
	
	/**
	 * Generate this View's XML layout node.
	 * 
	 * This should be overwritten in subclasses to add your own attributes or child nodes.
	 * 
	 * @param XML layout document.
	 * @return The element.
	 */
	public Element getLayoutElement(Document doc) {
	    Element component = doc.createElement(name);
	    // These will probably be overwritten by later components
	    component.setAttribute("android:id", androidId);
	    component.setAttribute("android:layout_width", "match_parent");
	    component.setAttribute("android:layout_height", "match_parent");
	    component.setAttribute("android:text", text);
	    component.setAttribute("android:textSize","8pt");
	    
	    // Set style
	    if (fragment != null) {
	    	component.setAttribute("style", fragment.getName());
	    }
	    
	    // Set margins
	    for (Constants.margin key : marginMap.keySet()){
	    	if (key == Constants.margin.TOP){
	    		component.setAttribute("android:layout_marginTop", Integer.toString((int) Constants.toDP(marginMap.get(key))) + "dp");
	    	}
	    	else if (key == Constants.margin.BOTTOM){
	    		component.setAttribute("android:layout_marginBottom", Integer.toString((int) Constants.toDP(marginMap.get(key))) + "dp");
	    	}
	    	else if (key == Constants.margin.END) {
	    		component.setAttribute("android:layout_marginEnd", Integer.toString((int) Constants.toDP(marginMap.get(key))) + "dp");
	    	}
	    	else{
	    		component.setAttribute("android:layout_marginStart", Integer.toString((int) Constants.toDP(marginMap.get(key))) + "dp");
	    	}
//	    if (childOfLinear){
//	    	component.setAttribute("android:layout_weight", Float.toString(weight));
//	    }
	    }
	    //need this so that parents can write children
	    elem = component;
	    return component;
	}
	
	/**
	 * takes the document, and margin magnitudes to write the xml in the case of absolute positioning
	 * @param doc
	 * @return
	 */
	public Element getLayoutElementAbsolute(Document doc, float leftMargin, float topMargin){
		Element component = doc.createElement(name);
	    // These will probably be overwritten by later components
	    component.setAttribute("android:id", androidId);
	    component.setAttribute("android:layout_width", Float.toString(Constants.toDP(this.getWidth())) + "dp");
	    component.setAttribute("android:layout_height", Float.toString(Constants.toDP(this.getHeight())) + "dp");
	    //email extensions could cause build fails, need to escape the @ character for xml
	    text = text.replaceAll("@", "\\@");
	    component.setAttribute("android:text", text);
	    component.setAttribute("android:textSize","8pt");	
	    
	    component.setAttribute("android:layout_marginTop", Float.toString(Constants.toDP((int) topMargin)) + "dp");
	    component.setAttribute("android:layout_marginStart", Float.toString(Constants.toDP((int) leftMargin)) + "dp");
	    
	    // Set style
	    if (fragment != null) {
	    	component.setAttribute("style", fragment.getName());
	    }
	    
	    return component;
	}
	
	/**
	 * Generate any resources (drawables, etc.) needed by this component.
	 * @param root Project root directory.
	 * @throws IOException If needed files can't be found, which happens often
	 */
	public void generateResources(Path root) throws IOException { }
	
	/**
	 * Set the activity this component refers to.
	 * Should be internal to XMLParser
	 */
	public void setActivity(ActivityHolder activity) {
		this.activity = activity;
	}
	
	public void setWeight(float w) {weight = w;}
	
	public float getWeight(){
		return weight;
	}
	
	public Element getElement() {return elem;}
	
	protected void setName(String nae){
		this.name = nae;
	}
	public void setValues(int x, int y, int w, int h){
		this.x = x;
		this.y = y;
		this.height = h;
		this.width = w;
	}
	
	public void setValues(int x, int y, int w, int h, String t) {
		this.x    = x;
		this.y    = y;
		this.width  = w;
		this.height = h;
		this.text   = t;
	}
	
	// Displayed text
	public void setText(String string){ text = string; }
	protected String getText() { return text; }
	
//	public void isLinear(){ childOfLinear = true; }
	// Component ID
	public int getId(){ return id; }
	public void setId(int x){ id = x; }
	
	// Android class name
	public String getName() {return name; }
	
	// Position
	public void setX(int x){ this.x  = x; }
	public void setY(int y){ this.y = y; }
	public void setWidth(int w){ this.width = w; }
	public void setHeight(int h){ this.height = h; }
	
	public int getX(){ return x; }
	public int getY(){ return y; }
	public int getHeight(){ return height;	}
	public int getWidth(){ return width; }
	
	public float getCenterX(){
		return x + width / 2;
	}
	
	public float getCenterY(){
		return y + height / 2;
	}
	
	public String getAndroidId() {
		return androidId;
	}
	
	public void setAndroidId(String id){
		androidId = id;
	}
	
	// Padding
	public void setPaddingTop(int padding)   { this.pTop = padding; }
	public void setPaddingBottom(int padding){ this.pBottom = padding; }
	public void setPaddingLeft(int padding)  { this.pLeft = padding; }
	public void setPaddingRight(int padding) { this.pRight = padding; }
	
	public int getPaddingTop()    { return this.pTop; }
	public int getPaddingBottom() { return this.pBottom; }
	public int getPaddingLeft()   { return this.pLeft; }
	public int getPaddingRight()  { return this.pRight; }

	@Override
	public String toString() {
		if (text == null) {
			return "{" + getName() + ", "
					   + (new Float(x).toString()) + ", "
					   + (new Float(y).toString()) + ", "
					   + (new Float(width).toString()) + ", "
					   + (new Float(height).toString())
					   + "}";
		} else {
			return "{" + getName() + ", "
					   + (new Float(x).toString()) + ", "
					   + (new Float(y).toString()) + ", "
					   + (new Float(width).toString()) + ", "
					   + (new Float(height).toString()) + ", "
					   + text + "}";			
		}
	}

	@Override
	public int compareTo(View o) {
		// TODO Auto-generated method stub
		return (int) (this.y - o.y);
	}

	/**
	 * Generate and return the style fragment, if any, associated with this object.
	 * 
	 * This may take some time to generate, so it might make sense to do
	 * this asynchronously. Style fragments are not cached, so you should
	 * store the result of this function as soon as you get it.
	 * 
	 * Some Views have no styles associated with them; in this case, this
	 * will return null.
	 * 
	 * @return
	 */
	public StyleFragment getStyleFragment() {
		if (fragment == null)
			initStyleFragment();
		return fragment;
	}
	
	protected void initStyleFragment() {
		fragment = null;
	}
	
	/**
	 * Merge the style fragments of two views, assigning the merged fragment to both.
	 * 
	 * The actual rules for merging are covered in StyleFragment. In general, things
	 * like color and dimension are averaged, whereas things that can't be merged
	 * easily (like Strings) are simply discarded from other.
	 * 
	 * @param other
	 */
	public void mergeStyleFragments(View other) {
		assert(fragment != null);
		assert(other.fragment != null);
		
		StyleFragment merged = fragment.mergeFragments(other.fragment);
		fragment = merged;
		other.fragment = merged;
	}
	
	/**
	 * Get the "distance" between two style fragments.
	 * 
	 * This is used in StyleBuilder's merging algorithms. The greater
	 * the distance, the less similar two styles are; a distance of infinity
	 * means that the two styles cannot reasonably be merged.
	 * 
	 * @param other
	 * @return
	 */
	public double getStyleDistance(View other) {
		if (fragment == null || other.fragment == null) {
			return Double.POSITIVE_INFINITY;
		}
		return fragment.distance(other.fragment);
	}
	
}
